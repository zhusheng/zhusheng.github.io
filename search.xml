<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/09/17/hello-world/"/>
      <url>/2019/09/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/05/22/docker-ji-chu-rong-qi/"/>
      <url>/2019/05/22/docker-ji-chu-rong-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h1><p>容器是镜像的实例，是一个独立的环境。</p><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><ul><li>方式1</li></ul><p>使用docker create容器，容器默认是停止状态的，需要使用docker start来启动容器。</p><pre class=" language-bash"><code class="language-bash">docker create -ti ubuntu:14.04docker start c498a45c62a9</code></pre><ul><li>方式2</li></ul><p>新建并启动-docker run,docker run等价与docker create +docker start</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 示例1</span>docker run ubuntu:14.04 /bin/echo <span class="token string">"hello world"</span><span class="token comment" spellcheck="true"># 示例2</span>docker run -it ubuntu:14.04 /bin/bash<span class="token comment" spellcheck="true"># 示例3:指定容器名称</span>docker run -it --name ubuntu_test1 ubuntu /bin/bash</code></pre><pre class=" language-bash"><code class="language-bash">Options:    -t, 让docker分配一个伪终端并绑定到容器的标准输入上    -i, 让容器的标准输入保持打开    -d, 表示在后台运行</code></pre><p>补充示例：下面的指令会在后台启动一个容器，而且每隔1秒输出一条语句</p><pre class=" language-bash"><code class="language-bash">docker run -d ubuntu:14.04 /bin/sh -c "while <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token keyword">echo</span> hello zhusheng<span class="token punctuation">;</span> <span class="token function">sleep</span> 1<span class="token punctuation">;</span> done”</code></pre><h2 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h2><pre class=" language-bash"><code class="language-bash">Docker logs  <span class="token operator">&lt;</span>container id<span class="token operator">></span></code></pre><h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 停止容器</span>docker stop <span class="token operator">&lt;</span>docker id<span class="token operator">></span><span class="token comment" spellcheck="true"># 强制杀死容器</span>docker <span class="token function">kill</span> <span class="token operator">&lt;</span>docker id<span class="token operator">></span></code></pre><h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看所有的容器，包含Exited、Up 状态的所有容器</span>docker <span class="token function">ps</span> -a<span class="token comment" spellcheck="true"># 查看运行的容器，Up 状态</span>docker <span class="token function">ps</span><span class="token comment" spellcheck="true"># 查看容器id</span>docker <span class="token function">ps</span> -a -qdocker <span class="token function">ps</span>  -q</code></pre><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 启动</span>docker start <span class="token operator">&lt;</span>docker id<span class="token operator">></span><span class="token comment" spellcheck="true"># 重启</span>docker restart <span class="token operator">&lt;</span>docker id<span class="token operator">></span></code></pre><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>带有-d参数启动的容器会在后台运行，用户无法看到容器中的信息，如下所示:</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 启动容器在后台运行</span>docker run -d ubuntu:14.04 /bin/bash</code></pre><p>如果现在我们需要进入容器，有几种方式，如下所示：<br>（1）attach,docker自带，但是窗口会自动同步<br>（2）exec, docker自带，更加高级<br>（3）nsenter工具，包含于util-linux包2.23之后的版本</p><ul><li>使用attach进入容器</li></ul><pre class=" language-bash"><code class="language-bash">docker attach <span class="token operator">&lt;</span>container id<span class="token operator">></span> or <span class="token operator">&lt;</span>container name<span class="token operator">></span></code></pre><ul><li>使用exec进入容器—推荐</li></ul><pre class=" language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it dd744b6466bf /bin/bash</code></pre><ul><li>使用nsenter</li></ul><p>安装nsenter</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /tmp<span class="token punctuation">;</span>curl https://www.kernel.org/pub/linux/utils/util-linux/v2.24/util-linux-2.24.tar.gz <span class="token operator">|</span> <span class="token function">tar</span> -zxvf-<span class="token punctuation">;</span> <span class="token function">cd</span> util-linux-2.24<span class="token punctuation">;</span>./configure --without-ncurses</code></pre><p>如果提示缺少gcc、cc、cl.exe，执行<code>yum install -y gcc</code>后重新执行检查<code>make nsenter &amp;&amp; cp nsenter /usr/local/bin</code></p><p>使用nsenter</p><p>每一个容器都有.State.Pid，所以这个命令除了容器的id需要我们根据docker ps -a去查找，其他的全部为固定的格式。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 获取.State.Pid</span>docker inspect -f <span class="token punctuation">{</span><span class="token punctuation">{</span>.State.Pid<span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">&lt;</span>container id<span class="token operator">></span> or <span class="token operator">&lt;</span>container name<span class="token operator">></span><span class="token comment" spellcheck="true"># 根据.State.Pid进入容器</span>nsenter --target <span class="token operator">&lt;</span>PID<span class="token operator">></span> --mount --uts --ipc --net –pid</code></pre><p>示意图如下：</p><p><img src="https://raw.githubusercontent.com/zhusheng/blog/master/docker/06.png" alt="image"></p><p>参数说明：</p><ul><li>mount参数是进去到mount namespace中</li><li>uts参数是进入到uts namespace中</li><li>ipc参数是进入到System V IPC namaspace中</li><li>net参数是进入到network namespace中</li><li>pid参数是进入到pid namespace中</li><li>user参数是进入到user namespace中</li></ul><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 删除</span>docker <span class="token function">rm</span> d2016d5fe1b3<span class="token comment" spellcheck="true"># 强制删除</span>docker <span class="token function">rm</span> -f d2016d5fe1b3<span class="token comment" spellcheck="true">#停用全部运行中的容器</span>docker stop <span class="token variable"><span class="token variable">$(</span>docker <span class="token function">ps</span> -q<span class="token variable">)</span></span><span class="token comment" spellcheck="true">#删除全部容器</span>docker <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span>docker <span class="token function">ps</span> -aq<span class="token variable">)</span></span><span class="token comment" spellcheck="true">#一条命令实现停用并删除容器</span>docker stop <span class="token variable"><span class="token variable">$(</span>docker <span class="token function">ps</span> -q<span class="token variable">)</span></span> <span class="token operator">&amp;</span> docker <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span>docker <span class="token function">ps</span> -aq<span class="token variable">)</span></span></code></pre><h2 id="Docker备份"><a href="#Docker备份" class="headerlink" title="Docker备份"></a>Docker备份</h2><h3 id="本地备份"><a href="#本地备份" class="headerlink" title="本地备份"></a>本地备份</h3><p>（1）导出容器<br>不管这个容器是什么状态，使用docker export导出成为一个压缩文件</p><pre class=" language-bash"><code class="language-bash">docker <span class="token function">export</span> ce5 <span class="token operator">></span> test_for_run.tar</code></pre><p>（2）导入容器<br>导入的容器会成为一个镜像</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> test_for_run.tar <span class="token operator">|</span> docker <span class="token function">import</span> - test/ubuntu:v1.0</code></pre><p>示意图如下：</p><p><img src="https://raw.githubusercontent.com/zhusheng/blog/master/docker/07.png" alt="image"></p><h3 id="Docker-Hub备份"><a href="#Docker-Hub备份" class="headerlink" title="Docker Hub备份"></a>Docker Hub备份</h3><p>（1）备份成镜像</p><pre class=" language-bash"><code class="language-bash">docker commit -p huatec01 zhushengdocker/hadoop3node:huatec01docker commit -p huatec02 zhushengdocker/hadoop3node:huatec02docker commit -p huatec03 zhushengdocker/hadoop3node:huatec03</code></pre><p><img src="https://raw.githubusercontent.com/zhusheng/blog/master/docker/08.png" alt="image"><br><img src="https://raw.githubusercontent.com/zhusheng/blog/master/docker/09.png" alt="image"></p><p>（2）登录docker账号</p><pre class=" language-bash"><code class="language-bash">docker login<span class="token comment" spellcheck="true">#输入用户名和密码</span></code></pre><p><img src="https://raw.githubusercontent.com/zhusheng/blog/master/docker/10.png" alt="image"></p><p>（3）上传镜像</p><pre class=" language-bash"><code class="language-bash">docker push zhushengdocker/hadoop3node:huatec01</code></pre><p><img src="https://raw.githubusercontent.com/zhusheng/blog/master/docker/11.png" alt="image"></p><p>（4）恢复镜像</p><pre class=" language-bash"><code class="language-bash">docker pull zhushengdocker/hadoop3node:huatec01</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker基础</title>
      <link href="/2019/05/22/docker-ji-chu/"/>
      <url>/2019/05/22/docker-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h1><h2 id="Docker-Hub账号"><a href="#Docker-Hub账号" class="headerlink" title="Docker Hub账号"></a>Docker Hub账号</h2><pre class=" language-bash"><code class="language-bash">Username：zhushengdockerPassword：xxxxxxx</code></pre><p>备注：Docker Hub逐渐迁移到Docker Store</p><p>阿里Docker Hub加速器可以提高国内对Docker的访问速度，我在阿里Docker Hub上注册了一个账号，系统会为每个人分配一个加速器地址，我的加速器地址为：<code>https://j95dutr4.mirror.aliyuncs.com</code>。我将其添加到我的Docker配置里面，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhusheng/blog/master/docker/24.png" alt="image"></p><h2 id="Docker-Hub仓库基本操作"><a href="#Docker-Hub仓库基本操作" class="headerlink" title="Docker Hub仓库基本操作"></a>Docker Hub仓库基本操作</h2><p>Ubuntu是一个仓库，它的各个版本分支对应具体的镜像，也就是说镜像是存储在仓库里的。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 搜索仓库</span>docker search Ubuntu<span class="token comment" spellcheck="true"># 从仓库下载镜像</span>docker pull ubuntu:14.04</code></pre><h2 id="私有仓库的创建和使用"><a href="#私有仓库的创建和使用" class="headerlink" title="私有仓库的创建和使用"></a>私有仓库的创建和使用</h2><p>1、在192.168.1.241机器上下载registry镜像，并启动一个仓库容器。安装完docker之后，可以通过官方提供的registry镜像简单搭建一个本地私有仓库，指令自动下载并启动一个registry容器，创建本地的私有仓库服务。默认仓库创建在容器的/tmp/registry目录下，也可以通过-v指定位置。监听端口为5000。示意图如下：</p><p><img src="https://raw.githubusercontent.com/zhusheng/blog/master/docker/25.png" alt="image"></p><p>2、在Mac上或其它机器安装有docker的机器上上传镜像到仓库，在Mac上下载一个busybox镜像，然后改名为192.168.1.241:5000/busybox，我们注意到前面的名称为仓库的ip:5000。示意图如下：</p><p><img src="https://raw.githubusercontent.com/zhusheng/blog/master/docker/26.png" alt="image"></p><p>上传镜像</p><pre class=" language-bash"><code class="language-bash">docker push 192.168.1.241:5000/busybox</code></pre><p>示意图如下：<br><img src="https://raw.githubusercontent.com/zhusheng/blog/master/docker/27.png" alt="image"></p><p>出错了是因为docker 1.3.x之后，与docker registry的交互默认采用的是https，我们修改Mac的docker配置文件daemon.json，在其中增加如下内容：”insecure-registries”: [“<ip>:5000”] ，我们可以同时增加多个ip。示意图如下：</ip></p><p><img src="https://raw.githubusercontent.com/zhusheng/blog/master/docker/28.png" alt="image"></p><p>重新执行上传，上传成功！示意图如下：</p><p><img src="https://raw.githubusercontent.com/zhusheng/blog/master/docker/29.png" alt="image"></p><p>3、查看仓库镜像列表</p><p><img src="https://raw.githubusercontent.com/zhusheng/blog/master/docker/30.png" alt="image"></p><p>4、下载仓库镜像</p><p><img src="https://raw.githubusercontent.com/zhusheng/blog/master/docker/31.png" alt="image"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/05/22/docker-ji-chu-jing-xiang/"/>
      <url>/2019/05/22/docker-ji-chu-jing-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h1><p>我们可以把常用的环境制作成Docker镜像， 然后基于镜像生成容器。比如我们可以把Hadoop做成一个镜像，然后我们可以基于这个镜像快速提供一个处于运行中的Hadoop环境。</p><p>Docker官方为我们提供了镜像仓库，Docker Hub，我们可以从其中搜索和下载我们需要的镜像。</p><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>从Docker Hub的Ubuntu仓库下载最新的镜像</p><pre class=" language-bash"><code class="language-bash">docker pull ubuntu或docker pull ubuntu:latest</code></pre><p>下载指定版本的镜像</p><pre class=" language-bash"><code class="language-bash">docker pull ubuntu:14.04</code></pre><p>说明：上面指令的实际全称是：<code>docker pull registry.hub.docker.com/ubuntu:14.04</code>,默认的注册服务器为<code>registry.hub.docker.com</code>.</p><h2 id="显示镜像列表"><a href="#显示镜像列表" class="headerlink" title="显示镜像列表"></a>显示镜像列表</h2><pre class=" language-bash"><code class="language-bash">docker images</code></pre><p>说明：罗列本地主机上已有的镜像，ID是镜像的唯一标示号，同一个ID的镜像可以有多个TAG，如果ID一样说明镜像就是相同的。</p><h2 id="获取镜像详细信息"><a href="#获取镜像详细信息" class="headerlink" title="获取镜像详细信息"></a>获取镜像详细信息</h2><pre class=" language-bash"><code class="language-bash">docker inspect <span class="token operator">&lt;</span>ID<span class="token operator">></span></code></pre><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>使用镜像创建一个容器，并运行bash应用</p><pre class=" language-bash"><code class="language-bash">docker run -it ubuntu /bin/bash</code></pre><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p>根据TAG或IMAGE ID进行删除操作，可以同时删除多个</p><pre class=" language-bash"><code class="language-bash">docker rmi <span class="token operator">&lt;</span>IMAGE1 IMAGE2 <span class="token punctuation">..</span>.<span class="token operator">></span></code></pre><p>根据TAG删除，先删除TAG，如果只有一个TAG，直接删除镜像本身</p><pre class=" language-bash"><code class="language-bash">docker rmi sshd</code></pre><p>根据id删除，直接删除镜像本身，无论有几个TAG。如果镜像有容器，需要先停止和删除相关的容器，然后才可以删除镜像。</p><pre class=" language-bash"><code class="language-bash">docker rmi 433478589107 c84640d67d8a</code></pre><p>我们也可以强制删除镜像，但不建议使用，可能会造成很多遗留问题。</p><pre class=" language-bash"><code class="language-bash">docker rmi -f 433478589107</code></pre><p>说明：如果镜像有容器的话，需要先删除容器，然后删除镜像。查看本机上的所有容器“docker ps -a”，删除容器“docker rm e81”。无论是删除容器还是删除镜像，在填写ID的时候我们可以只写前面的几个字符，只要保证是唯一的即可。</p><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>方式有三种：基于已有镜像的容器创建、基于本地模版导入、基于Dockerfile创建。最常见的是基于Dockerfile创建，其次是基于已有镜像的容器创建。</p><ul><li>方式1:基于已有镜像的容器创建</li></ul><p>根据已有的镜像创建一个容器；在容器中修改内容，如安装软件、新增文件等；保存容器为新的<br>镜像。指令格式如下：<code>docker commit [options] CONTAINER [REPOSITORY[:TAG]]</code></p><pre class=" language-bash"><code class="language-bash">options:    -a, author，作者信息    -m,    message，提交信息    -p, pause， 提交时暂停容器运行</code></pre><p>示例如下：</p><pre class=" language-bash"><code class="language-bash">docker commit -m <span class="token string">"Added json gem"</span> -a <span class="token string">"zhusheng"</span> 0b2616b0e5a8 ouruser/sinatra:v2</code></pre><p>说明：说明：<code>0b2616b0e5a8</code>为容器ID；<code>ouruser/sinatra:v2</code>为<code>REPOSITORY:TAG</code></p><ul><li>方式2:基于本地模版导入</li></ul><p>模版下载地址，推荐使用<a href="http://openvz.org/Download/templates/precreated" target="_blank" rel="noopener">OpenVZ模版</a></p><p>示例：下载ubuntu-14.04模版压缩包，进行导入操作</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> ubuntu-14.04-x86_64-minimal.tag.gz <span class="token operator">|</span>docker <span class="token function">import</span> - ubuntu:14.04</code></pre><ul><li>方式3:使用Dockerfile制作镜像</li></ul><p>Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile快速创建自定义的镜像。制作镜像的指令:<code>docker build -t &lt;IMAGE NAME&gt; .</code></p><p>Dockerfile使用步骤：首先，在宿主机下新建一个文件下作为工作目录；然后，进入该工作目录，创建一个Dockerfile，我们在Dockerfile文件中编写我们生成镜像的代码逻辑。我们可以将过程中需要用到的软件放到工作目录下，在Dockerfile中使用ADD添加，也可以在工作目录下编写一些脚本，然后在Dockerfile中调用；最后，在工作目录下，执行创建镜像指令。</p><p>示例：</p><pre class=" language-bash"><code class="language-bash">docker build -t zhusheng/mysql5.6:dockerfile <span class="token keyword">.</span></code></pre><p>注意：结尾有一个“.”</p><h2 id="存出和载入镜像"><a href="#存出和载入镜像" class="headerlink" title="存出和载入镜像"></a>存出和载入镜像</h2><ul><li>存出镜像为本地文件</li></ul><pre class=" language-bash"><code class="language-bash">docker save -o ubuntu_14.04.tar ubuntu:14.04</code></pre><p>示意图如下：</p><p><img src="https://raw.githubusercontent.com/zhusheng/blog/master/docker/01.png" alt="image"></p><ul><li>导入本地文件为镜像</li></ul><pre class=" language-bash"><code class="language-bash">docker load <span class="token operator">&lt;</span> ubuntu_14.04.tar或docker load --input ubuntu_14.04.tar</code></pre><p><img src="https://raw.githubusercontent.com/zhusheng/blog/master/docker/02.png" alt="image"></p><h2 id="上传镜像到Docker-Hub仓库"><a href="#上传镜像到Docker-Hub仓库" class="headerlink" title="上传镜像到Docker Hub仓库"></a>上传镜像到Docker Hub仓库</h2><p>首先需要注册Docker账号;</p><p>其次是tag名称格式必须为：<code>&lt;docker username&gt;/imagename:tag</code></p><p>示例:</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 添加新的标签</span>docker tag hello-world zhushengdocker/hello-world:1.0<span class="token comment" spellcheck="true"># 上传镜像</span>docker push zhushengdocker/hello-world:1.0</code></pre><p>示意图如下：</p><p><img src="https://raw.githubusercontent.com/zhusheng/blog/master/docker/03.png" alt="image"></p><p>我们登录Docker账号查看效果:</p><p><img src="https://raw.githubusercontent.com/zhusheng/blog/master/docker/04.png" alt="image"></p><h2 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h2><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">阿里云访问地址</a></p><p>进入阿里云容器Hub服务的控制台，并申请成为开发者。点击左侧的加速器帮助页面就会显示你的专属加速器地址。阿里为每个人都给了一个私有的个人加速器。我的个人加速器地址为：<code>https://j95dutr4.mirror.aliyuncs.com</code></p><p>示意图如下：</p><p><img src="https://raw.githubusercontent.com/zhusheng/blog/master/docker/05.png" alt="image"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>typora-vue-theme Theme introduction</title>
      <link href="/2018/09/07/example/"/>
      <url>/2018/09/07/example/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
